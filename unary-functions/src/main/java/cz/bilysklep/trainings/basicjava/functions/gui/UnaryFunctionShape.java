package cz.bilysklep.trainings.basicjava.functions.gui;

import cz.bilysklep.trainings.basicjava.functions.UnaryFunction;
import java.awt.Rectangle;
import java.awt.Shape;
import java.awt.geom.AffineTransform;
import java.awt.geom.PathIterator;
import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;

/**
 * This class represents shape generated by given unary function.
 *
 * @author Petr Adamek
 */
public class UnaryFunctionShape implements Shape {

    private final UnaryFunction function;
    private double minX;
    private double maxX;
    private double deltaX;
    private Rectangle2D bounds;

    /**
     * This constructor creates new instance of shape, that is generated
     * by given function in given interval from minX to maxX using given
     * step deltaX.
     *
     * @param function Function that generates this shape
     * @param minX low boundary of x coordinate
     * @param maxX high boundary of x coordinate
     * @param deltaX step using in evaluating given function
     */
    public UnaryFunctionShape(UnaryFunction function,
            double minX, double maxX, double deltaX) {

        this.function = function;
        if (minX > maxX) {
            throw new IllegalArgumentException("minX must be less then maxX");
        }
        this.minX = minX;
        this.maxX = maxX;
        this.deltaX = deltaX;
        initCache();
    }

    @Override
    public Rectangle getBounds() {
        return getBounds2D().getBounds();
    }

    private Rectangle2D computeBounds() {

        double boundsMinX = Double.POSITIVE_INFINITY;
        double boundsMaxX = Double.NEGATIVE_INFINITY;
        double boundsMinY = Double.POSITIVE_INFINITY;
        double boundsMaxY = Double.NEGATIVE_INFINITY;

        for (double x = minX; x <= maxX; x += deltaX) {
            if (isFunctionDefinedFor(x)) {
                double y = getFunctionValue(x);
                if (x > boundsMaxX) { boundsMaxX = x; }
                if (x < boundsMinX) { boundsMinX = x; }
                if (y > boundsMaxY) { boundsMaxY = y; }
                if (y < boundsMinY) { boundsMinY = y; }
            }
        }
        if (boundsMinX < boundsMaxX && boundsMinY < boundsMaxY) {
            return new Rectangle2D.Double(boundsMinX,boundsMinY,
                    boundsMaxX - boundsMinX,
                    boundsMaxY - boundsMinY);
        } else {
            return new Rectangle2D.Double();
        }
    }

    @Override
    public Rectangle2D getBounds2D() {
        if (bounds == null) {
            bounds = computeBounds();
        }
        return bounds;
    }

    @Override
    public boolean contains(double d, double d0) {
        return false;
    }

    @Override
    public boolean contains(Point2D point2D) {
        return false;
    }

    @Override
    public boolean intersects(double x, double y, double w, double h) {
        return intersects(new Rectangle2D.Double(x,y,w,h));
    }

    @Override
    public boolean intersects(Rectangle2D r) {
        if (getBounds2D().intersects(r)) {
            double fromX = Math.max(minX,r.getMinX());
            double toX = Math.min(maxX,r.getMaxX());
            for (double x = fromX; x <= toX; x += deltaX) {
                if (isFunctionDefinedFor(x)) {
                    double y = getFunctionValue(x);
                    if (r.contains(x,y)) {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    @Override
    public boolean contains(double d, double d0, double d1, double d2) {
        return false;
    }

    @Override
    public boolean contains(Rectangle2D rectangle2D) {
        return false;
    }

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform) {
        return new UnaryFunctionPathIterator(affineTransform);
    }

    @Override
    public PathIterator getPathIterator(AffineTransform affineTransform, double d) {
        return new UnaryFunctionPathIterator(affineTransform);
    }

    private class UnaryFunctionPathIterator implements PathIterator {

        private double x = minX;
        private final AffineTransform affine;

        private Point2D lastPoint = null;

        private double smallDelta;
        private void incrementX() {
            if (smallDelta > 0) {
                x += smallDelta;
                smallDelta = 0;
            }
            // x = 0 is important point, don't miss them
            else if (x < 0 && x > (-deltaX)) {
                smallDelta = -x;
                x = 0;
            } else {
                x += deltaX;
            }
        }

        private void seekNextValidX() {
            while(!isDone() && !isFunctionDefinedFor(x)) {
                incrementX();
            }
        }

        private UnaryFunctionPathIterator(AffineTransform affine) {
            this.affine = affine;
            seekNextValidX();
        }

        @Override
        public int currentSegment(double[] coords) {
            int nextMove;
            if (isFunctionDefinedFor(x)) {
                coords[0] = x;
                coords[1] = getFunctionValue(x);
                if (lastPoint != null) {
                    nextMove = SEG_LINETO;
                } else {
                    nextMove = SEG_MOVETO;
                }
                lastPoint = new Point2D.Double(coords[0],coords[1]);
            } else {
                coords[0] = lastPoint.getX();
                coords[1] = lastPoint.getY();
                nextMove = SEG_LINETO;
                lastPoint = null;
            }
            if (affine != null) {
                affine.transform(coords, 0, coords, 0, 1);
            }
            return nextMove;
        }

        @Override
        public int currentSegment(float[] coords) {
            double[] buffer = new double[2];
            int result = currentSegment(buffer);
            coords[0] = (float) buffer[0];
            coords[1] = (float) buffer[1];
            return result;
        }

        private boolean lastSegment;

        @Override
        public void next() {
            incrementX();
            if (x > maxX && !lastSegment) {
                // this ensures drawing of last incomplete segment
                x = maxX;
                lastSegment = true;
            }
            if (!isFunctionDefinedFor(x) && (lastPoint == null)) {
                seekNextValidX();
            }
        }

        @Override
        public boolean isDone() {
            return x > maxX;
        }

        @Override
        public int getWindingRule() {
            return WIND_NON_ZERO;
        }

    }

//    private int getIndex(double x) {
//        return (int) Math.round((x - minX) / deltaX);
//    }

    private void initCache() {
//        cache = new double[getIndex(maxX) + 1];
//        for (double x = minX; x <= maxX; x += deltaX) {
//            if (isFunctionDefinedFor(x)) {
//                cache[getIndex(x)] = function.getValue(x);
//            } else {
//                cache[getIndex(x)] = Double.NaN;
//            }
//        }
    }

//    private double[] cache;

    private double getFunctionValue(double x) {
//        return cache[getIndex(x)];
        return function.getValue(x);
    }

    private boolean isFunctionDefinedFor(double x) {
        return function.isDefinedFor(x);
//        return cache[getIndex(x)] != Double.NaN;
    }
}
